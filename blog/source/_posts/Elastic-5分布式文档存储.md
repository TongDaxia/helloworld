---
title: Elastic-5分布式文档存储
date: 2019-05-31 14:26:00
tags: [java,分布式,Elastic]
---

##### 分片位置的确定

```
shard = hash(routing) % number_of_primary_shards
```

`routing` 通过 hash 函数生成一个数字，然后这个数字再除以 `number_of_primary_shards` （主分片的数量）后得到 **余数** 。

这就解释了为什么我们要在创建索引的时候就确定好主分片的数量 并且永远不会改变这个数量：因为如果数量变化了，那么所有之前路由的值都会无效，文档也再也找不到了。

> 你可能觉得由于 Elasticsearch 主分片数量是固定的会使索引难以进行扩容。实际上当你需要时有很多技巧可以轻松实现扩容。我们将会在[*扩容设计*](https://www.elastic.co/guide/cn/elasticsearch/guide/current/scale.html)一章中提到更多有关水平扩展的内容。

所有的文档 API（ `get` 、 `index` 、 `delete` 、 `bulk` 、 `update` 以及 `mget` ）都接受一个叫做 `routing` 的路由参数 ，通过这个参数我们可以自定义文档到分片的映射。一个自定义的路由参数可以用来确保所有相关的文档——例如所有属于同一个用户的文档——都被存储到同一个分片中。我们也会在[*扩容设计*](https://www.elastic.co/guide/cn/elasticsearch/guide/current/scale.html)这一章中详细讨论为什么会有这样一种需求。

##### 主分片和副分片如何交互

可以发送请求到集群中的任一节点。 每个节点都有能力处理任意请求。 每个节点都知道集群中任一文档位置，所以可以直接将请求转发到需要的节点上。 在下面的例子中，将所有的请求发送到 `Node 1` ，我们将其称为 *协调节点(coordinating node)* 。

> 当发送请求的时候， 为了扩展负载，更好的做法是轮询集群中所有的节点。



![elas_0402](E:\tyg\study\blog\source\_posts\img\elas_0402.png)

以下是在主副分片和任何副本分片上面 成功新建，索引和删除文档所需要的

> 1. 客户端向 `Node 1` 发送新建、索引或者删除请求。
> 2. 节点使用文档的 `_id` 确定文档属于分片 0 。请求会被转发到 `Node 3`，因为分片 0 的主分片目前被分配在 `Node 3` 上。
> 3. `Node 3` 在主分片上面执行请求。如果成功了，它将请求并行转发到 `Node 1` 和 `Node 2` 的副本分片上。一旦所有的副本分片都报告成功, `Node 3` 将向协调节点报告成功，协调节点向客户端报告成功。

![elas_0402](E:\tyg\study\blog\source\_posts\img\elas_0403.png)

以下是从主分片或者副本分片检索文档的步骤顺序：

> 1、客户端向 `Node 1` 发送获取请求。
>
> 2、节点使用文档的 `_id` 来确定文档属于分片 `0` 。分片 `0` 的副本分片存在于所有的三个节点上。 在这种情况下，它将请求转发到 `Node 2` 。
>
> 3、`Node 2` 将文档返回给 `Node 1` ，然后将文档返回给客户端。

在处理读取请求时，协调结点在每次请求的时候都会通过轮询所有的副本分片来达到负载均衡。

在文档被检索时，已经被索引的文档可能已经存在于主分片上但是还没有复制到副本分片。 在这种情况下，副本分片可能会报告文档不存在，但是主分片可能成功返回文档。 一旦索引请求成功返回给用户，文档在主分片和副本分片都是可用的。

![elas_0402](E:\tyg\study\blog\source\_posts\img\elas_0404.png)

以下是部分更新一个文档的步骤：

> 1. 客户端向 `Node 1` 发送更新请求。
> 2. 它将请求转发到主分片所在的 `Node 3` 。
> 3. `Node 3` 从主分片检索文档，修改 `_source` 字段中的 JSON ，并且尝试重新索引主分片的文档。 如果文档已经被另一个进程修改，它会重试步骤 3 ，超过 `retry_on_conflict` 次后放弃。
> 4. 如果 `Node 3` 成功地更新文档，它将新版本的文档并行转发到 `Node 1` 和 `Node 2`上的副本分片，重新建立索引。 一旦所有副本分片都返回成功， `Node 3` 向协调节点也返回成功，协调节点向客户端返回成功。

##### 搜索的执行

*搜索（search）* 可以做到：

- 在类似于 `gender` 或者 `age` 这样的字段 上使用结构化查询，`join_date` 这样的字段上使用排序，就像SQL的结构化查询一样。
- 全文检索，找出所有匹配关键字的文档并按照*相关性（relevance）* 排序后返回结果。
- 以上二者兼而有之。

> *映射（Mapping）*		描述数据在每个字段内如何存储
>
> *分析（Analysis）*		全文是如何处理使之可以被搜索的
>
> *领域特定查询语言（Query DSL）*	Elasticsearch 中强大灵活的查询语言

###### 空搜索

```js
GET /_search
```

###### 多索引，多搜索

```
/gb/_search
```

在 `gb` 索引中搜索所有的类型

```
/gb,us/_search
```

在 `gb` 和 `us` 索引中搜索所有的文档

```
/g*,u*/_search
```

在任何以 `g` 或者 `u` 开头的索引中搜索所有的类型

```
/gb/user/_search
```

在 `gb` 索引中搜索 `user` 类型

```
/gb,us/user,tweet/_search
```

在 `gb` 和 `us` 索引中搜索 `user` 和 `tweet` 类型

```
/_all/user,tweet/_search
```

在所有的索引中搜索 `user` 和 `tweet` 类型

> 搜索一个索引有五个主分片和搜索五个索引各有一个分片准确来所说是等价的。

###### 分页

```
size
```

显示应该返回的结果数量，默认是 `10`

```
from
```

显示应该跳过的初始结果数量，默认是 `0`

考虑到分页过深以及一次请求太多结果的情况，结果集在返回之前先进行排序。 但请记住一个请求经常跨越多个分片，每个分片都产生自己的排序结果，这些结果需要进行集中排序以保证整体顺序是正确的。

但是，查的太深就会变得很困难：

```
我们可以假设在一个有 5 个主分片的索引中搜索。 当我们请求结果的第一页（结果从 1 到 10 ），每一个分片产生前 10 的结果，并且返回给 *协调节点* ，协调节点对 50 个结果排序得到全部结果的前 10 个。

现在假设我们请求第 1000 页--结果从 10001 到 10010 。所有都以相同的方式工作除了每个分片不得不产生前10010个结果以外。 然后协调节点对全部 50050 个结果排序最后丢弃掉这些结果中的 50040 个结果。

可以看到，在分布式系统中，对结果排序的成本随分页的深度成指数上升。这就是 web 搜索引擎对任何查询都不要返回超过 1000 个结果的原因。
```

##### 轻量搜索

查询字符串搜索非常适用于通过命令行做即席查询。例如，查询在 `tweet` 类型中 `tweet`字段包含 `elasticsearch` 单词的所有文档：

```js
GET /_all/tweet/_search?q=tweet:elasticsearch
```

```
+name:john +tweet:mary
```

但是查询字符串参数所需要的 *百分比编码* （译者注：URL编码）实际上更加难懂：

```js
GET /_search?q=%2Bname%3Ajohn+%2Btweet%3Amary
```

##### 怎么使得文本可被搜索

**倒排索引**

它会保存每一个词项出现过的文档总数， 在对应的文档中一个具体词项出现的总次数，词项在文档中的顺序，每个文档的长度，所有文档的平均长度，等等。

为了能够实现预期功能，倒排索引需要知道集合中的 *所有* 文档，这是需要认识到的关键问题。

##### 不变性

倒排索引被写入磁盘后是 *不可改变* 的:它永远不会修改。 不变性有重要的价值：

- 不需要锁。如果你从来不更新索引，你就不需要担心多进程同时修改数据的问题。
- 一旦索引被读入内核的文件系统缓存，便会留在哪里，由于其不变性。只要文件系统缓存中还有足够的空间，那么大部分读请求会直接请求内存，而不会命中磁盘。这提供了很大的性能提升。
- 其它缓存(像filter缓存)，在索引的生命周期内始终有效。它们不需要在每次数据改变时被重建，因为数据不会变化。
- 写入单个大的倒排索引允许数据被压缩，减少磁盘 I/O 和 需要被缓存到内存的索引的使用量。

怎样在保留不变性的前提下实现倒排索引的更新？ 答案是: 用更多的索引。

通过增加新的补充索引来反映新近的修改，而不是直接重写整个倒排索引。每一个倒排索引都会被轮流查询到--从最早的开始--查询完后再对结果进行合并。





  







##### 索引与分片的比较

被混淆的概念是，一个 *Lucene 索引* 我们在 Elasticsearch 称作 *分片* 。 一个 Elasticsearch *索引* 是分片的集合。 当 Elasticsearch 在索引中搜索的时候， 他发送查询到每一个属于索引的分片(Lucene 索引)，然后像 [*执行分布式检索*](https://www.elastic.co/guide/cn/elasticsearch/guide/current/distributed-search.html)提到的那样，合并每个分片的结果到一个全局的结果集。

##### 删除和更新

段是不可改变的，所以既不能从把文档从旧的段中移除，也不能修改旧的段来进行反映文档的更新。 取而代之的是，每个提交点会包含一个 `.del` 文件，文件中会列出这些被删除文档的段信息。

当一个文档被 “删除” 时，它实际上只是在 `.del` 文件中被 *标记* 删除。一个被标记删除的文档仍然可以被查询匹配到， 但它会在最终结果被返回前从结果集中移除。

文档更新也是类似的操作方式：当一个文档被更新时，旧版本文档被标记删除，文档的新版本被索引到一个新的段中。 可能两个版本的文档都会被一个查询匹配到，但被删除的那个旧版本文档在结果集返回前就已经被移除。