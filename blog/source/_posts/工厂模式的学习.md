---
title: 工厂模式的学习
date: 2019-05-27 
tags: [java,设计模式] 
description: 工厂模式就是抽象化创建类实例的过程，将对象和创建和使用进行解耦。
---

工厂模式的基本含义就是抽象化创建类实例的过程，将对象和创建和使用进行解耦。又称创建型模式，Creational Pattern。所以工厂模式的主要作用就是帮组进行实例化对象的。

<!--more-->

工厂模式分为以下三种：

- 简单工厂 Simple Simple 

- 工厂方法 Factory Method

- 抽象工厂 Abstract Factory


## 简单工厂

简单工厂就是静态工厂方法，Static Factory Method。由一个工厂对象决定创建哪一种产品的实例。

```
OperationFactory:根据条件判断生成哪个实例，是整个模式的核心。
Operation：生成产品的父类或者接口。
ConcreteProduct：就是生成的具体实例。
```

问题：

工厂类中集中了所有实例的创建逻辑，违反了高内聚责任分配原则。如果需要新增一个类型的产品实例，那么简单工厂模式必须改变工厂类了。系统维护性和可拓展新不高。

## 工厂方法

工厂方法模式，Factory Method Pattern 又叫虚拟构造器模式 Virtual Constructor 或者多态工厂模式 Polymorphic Factory。

其实就是定义了一个创建对象的接口，让实现这个接口的类来决定实例化哪个类。

```
抽象产品 Operation
具体产品 ConcreteProduct
抽象工厂 Factory
具体工厂 ConcreteFactory
```

**为什么要使用工厂方法创建对象：**

在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。

问题：

- 新增产品的时候需要新增具体的产品类和具体的工厂类，增加了系统的复杂性并且会给系统带来更大的负担。
- 设计复杂业务可能会涉及DOM、反射等技术，增加了系统的实现难度。



## 抽象工厂

抽象工厂模式，Abstract Factory Pattern，

有一个接口能创建一系列相关（相互依赖）的对象。

将同一产品族的单独工厂封装起来，客户端需要创建抽象工厂的具体实现，使用抽象工厂作为接口创建某一具体的对象。客户端并不知道创建的具体时间哪个对象，因为他使用的也是对象的通用接口。

抽象工厂模式和工厂方法模式一样，都符合开放-封闭原则。但是不同的是，工厂方法模式在增加一个具体产品的时候，都要增加对应的工厂。但是抽象工厂模式只有在新增一个类型的具体产品时才需要新增工厂。

```
抽象工厂 AbstractFactory；
具体工厂 ConcreteFactory；
抽象产品 AbstractProduct；
具体产品 Product
```

开闭原则的倾斜性

新增一个产品族比较容易，增加一个接口并填充对应的实现类接行了；但是增加新的产品等级结构需要修改所有的工厂角色，包括抽象工厂类，比较繁琐。

抽象工厂模式的这种性质称为“开闭原则”的倾斜性，抽象工厂模式以一种倾斜的方式支持增加新的产品，它为新产品族的增加提供方便，但不能为新的产品等级结构的增加提供这样的方便。

抽象工厂模式的主要优点是隔离了具体类的生成，使得客户并不需要知道什么被创建，而且每次可以通过具体工厂类创建一个产品族中的多个对象，增加或者替换产品族比较方便，增加新的具体工厂和产品族很方便；主要缺点在于增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，对“开闭原则”的支持呈现倾斜性。











