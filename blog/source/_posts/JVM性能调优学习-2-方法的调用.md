---
title: JVM性能调优学习-2-方法的调用
date: 2019-11-30 
tags: [java,JVM,调优]
---



# JVM如何执行方法

为什么不能通过方法的返回参数进行重载：

 Java 编译器会直接选取第一个方法名以及参数类型匹配的方法。
 并且，它会根据所选取方法的返回类型来决定可不可以通过编译，以及需不需要进行值转换等。

1. 在不考虑对基本类型自动装拆箱（auto-boxing，auto-unboxing），以及可变长参数的情况下选取重载方法；
2. 如果在第 1 个阶段中没有找到适配的方法，那么在允许自动装拆箱，但不允许可变长参数的情况下选取重载方法；
3. 如果在第 2 个阶段中没有找到适配的方法，那么在允许自动装拆箱以及可变长参数的情况下选取重载方法。

如果 Java 编译器在同一个阶段中找到了多个适配的方法，那么它会在其中选择一个最为贴切的，而决定贴切程度的一个关键就是形式参数类型的继承关系。

如果子类定义了与父类中非私有方法同名的方法，而且这两个方法的参数类型不同，那么在子类中，这两个方法同样构成了重载。

如果子类定义了与父类中非私有方法同名的方法，而且这两个方法的参数类型不同，那么在子类中，这两个方法同样构成了重载。如果这两个方法都是静态的，子类中的方法隐藏了父类中的方法。两个方法都不是静态的，且都不是私有的，那么子类的方法重写了父类中的方法。

## JVM 的静态绑定和动态绑定

Java 虚拟机识别方法的关键在于 **类名** 、 **方法名** 以及 **方法描述符** （method descriptor）。方法描述符，它是由方法的 **参数类型以及返回类型** 所构成。在同一个类中，如果同时出现多个名字相同且描述符也相同的方法，那么 Java 虚拟机会在类的验证阶段报错。

> Java 虚拟机与 Java 语言不同，它并不限制名字与参数类型相同，但返回类型不同的方法出现在同一个类中，对于调用这些方法的字节码来说，由于字节码所附带的方法描述符包含了返回类型，因此 Java 虚拟机能够准确地识别目标方法。



如果子类定义了与父类中非私有、非静态方法同名的方法，那么只有当这两个方法的参数类型以及返回类型一致，Java 虚拟机才会判定为重写。

对于 Java 语言中重写而 Java 虚拟机中非重写的情况，编译器会通过生成桥接方法 [2] 来实现 Java 中的重写语义。

重载也被称为静态绑定（static binding），或者编译时多态（compile-time polymorphism）；而重写则被称为动态绑定（dynamic binding）。

这个说法在 Java 虚拟机语境下并非完全正确。这是因为某个类中的重载方法可能被它的子类所重写，因此 Java 编译器会将所有对非私有实例方法的调用编译为需要动态绑定的类型。

Java 字节码与调用相关的指令

1. invokestatic：用于调用静态方法。
2. invokespecial：用于调用私有实例方法、构造器，以及使用 super 关键字调用父类的实例方法或构造器，和所实现接口的默认方法。
3. invokevirtual：用于调用非私有实例方法。
4. invokeinterface：用于调用接口方法。
5. invokedynamic：用于调用动态方法。



在 Java 虚拟机中，静态绑定指的是在解析时便能够直接识别目标方法的情况，而动态绑定则指的是需要在运行过程中根据调用者的动态类型来识别目标方法的情况。由于 Java 编译器已经区分了重载的方法，因此可以认为 Java 虚拟机中不存在重载。

在 class 文件中，**Java 编译器会用符号引用指代目标方法**。在执行调用指令前，它所附带的符号引用需要被解析成实际引用。对于可以静态绑定的方法调用而言**，实际引用为目标方法的指针**。对于需要动态绑定的方法调用而言，**实际引用为辅助动态绑定的信息**。

Java 的重写与 Java 虚拟机中的重写并不一致，但是编译器会通过生成桥接方法来弥补。



## 虚方法调用

Java 里所有非私有实例方法调用都会被编译成 **invokevirtual** 指令，而接口方法调用都会被编译成 **invokeinterface** 指令。这两种指令，均属于 Java 虚拟机中的**虚方法调用**。

在绝大多数情况下，Java 虚拟机需要**根据调用者的动态类型，来确定虚方法调用的目标方法**。这个过程我们称之为动态绑定。那么，相对于静态绑定的非虚方法调用来说，虚方法调用更加耗时。



**静态绑定**包括用于调用静态方法的 **invokestatic** 指令，和用于调用构造器、私有实例方法以及超类非私有实例方法的 **invokespecial** 指令。如果虚方法调用指向一个标记为 **final** 的方法，那么 Java 虚拟机也可以静态绑定该虚方法调用的目标方法。

Java 虚拟机中采取了一种用空间换取时间的策略来实现动态绑定。它为每个类生成一张方法表，用以快速定位目标方法。

## 方法表

Java 虚拟机的动态绑定是通过方法表这一数据结构来实现的。

在**类加载的准备阶段**，它除了为静态字段分配内存之外，还会构造与该类相关联的方法表。

方法表本质上是一个数组，每个数组元素指向一个当前类及其祖先类中非私有的实例方法。

方法表满足两个特质：其一，子类方法表中包含父类方法表中的所有方法；其二，子类方法在方法表中的索引值，与它所重写的父类方法的索引值相同。

使用了方法表的动态绑定与静态绑定相比，仅仅多出几个内存解引用操作：访问栈上的调用者，读取调用者的动态类型，读取该类型的方法表，读取方法表中某个索引值所对应的目标方法。相对于创建并初始化 Java 栈帧来说，这几个内存解引用操作的开销简直可以忽略不计。



## 内联缓存

**内联缓存**是一种加快动态绑定的优化技术。它能够**缓存虚方法调用中调用者的动态类型** ，以及该类型所对应的目标方法。在之后的执行过程中，如果碰到已缓存的类型，内联缓存便会直接调用该类型所对应的目标方法。如果没有碰到已缓存的类型，内联缓存则会退化至使用基于方法表的动态绑定。

在针对多态的优化手段中，我们通常会提及以下三个术语。

1. **单态**（monomorphic）指的是仅有一种状态的情况。
2. **多态**（polymorphic）指的是有限数量种状态的情况。二态（bimorphic）是多态的其中一种。
3. **超多态**（megamorphic）指的是更多种状态的情况。通常我们用一个具体数值来区分多态和超多态。在这个数值之下，我们称之为多态。否则，我们称之为超多态。

Java 虚拟机中的即时编译器会使用内联缓存来加速动态绑定。Java 虚拟机所采用的单态内联缓存将纪录调用者的动态类型，以及它所对应的目标方法。









