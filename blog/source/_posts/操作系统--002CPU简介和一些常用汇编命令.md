---
title: 操作系统--002 CPU简介和一些常用汇编命令
date: 2019-09-19 
tags: [操作系统]
---



**CPU**

CPU 其实也不是单纯的一块，它包括三个部分，运算单元、数据单元和控制单元。

**运算单元**只管算，例如做加法、做位移等等。但是，它不知道应该算哪些数据，运算结果应该放在哪里。

**数据单元**包括 CPU 内部的**缓存**和**寄存器组**，空间很小，但是速度飞快，可以暂时存放数据和运算结果。

**控制单元**是一个统一的指挥中心，它可以获得下一条指令，然后执行这条指令。这个指令会指导运算单元取出数据单元中的某几个数据，计算出个结果，然后放在数据单元的某个地方。CPU 的控制单元里面，有一个**指令指针寄存器**，执行的是下一条指令在内存中的地址。控制单元会不停地将代码段的指令拿进来，先放入指令寄存器。

CPU 和内存来来回回传数据，靠的都是总线。其实总线上主要有两类数据，一个是地址数据，也就是我想拿内存中哪个位置的数据，这类总线叫**地址总线**（Address Bus）；另一类是真正的数据，这类总线叫**数据总线**（Data Bus）。

地址总线的位数，决定了能访问的地址范围到底有多广。例如只有两位，那 CPU 就只能认 00，
01，10，11 四个位置，超过四个位置，就区分不出来了。位数越多，能够访问的位置就越多，能管理的内存的范围也就越广。
而数据总线的位数，决定了一次能拿多少个数据进来。例如只有两位，那 CPU 一次只能从内存拿两位数。要想拿八位，就要拿四次。位数越多，一次拿的数据就越多，访问速度也就越快。



![cpu](.\img\cpu.png)

为了暂存数据，8086 处理器内部有 8 个 16 位的通用寄存器，也就是刚才说的 CPU 内部的数据单元，分别是 AX、BX、CX、DX、SP、BP、SI、DI。这些寄存器主要用于在计算过程中暂存数据。
这些寄存器比较灵活，其中 AX、BX、CX、DX 可以分成两个 8 位的寄存器来使用，分别是 AH、AL、BH、BL、CH、CL、DH、DL，其中 H 就是 High（高位），L 就是 Low（低位）的意思。这样，比较长的数据也能暂存，比较短的数据也能暂存。

接着我们来看控制单元。
IP 寄存器就是指令指针寄存器（Instruction Pointer Register)，指向代码段中下一条指令的位置。CPU 会根据它来不断地将指令从内存的代码段中，加载到 CPU 的指令队列中，然后交给运算单元去执行。
如果需要切换进程呢？每个进程都分代码段和数据段，为了指向不同进程的地址空间，有四个 16位的段寄存器，分别是 CS、DS、SS、ES。
其中，CS 就是**代码段寄存器**（Code Segment Register），通过它可以找到代码在内存中的位置；DS 是**数据段的寄存器**，通过它可以找到数据在内存中的位置。SS 是**栈寄存器**（Stack Register）。栈是程序运行中一个特殊的数据结构，数据的存取只能从一端进行，秉承后进先出的原则，push 就是入栈，pop 就是出栈。

如果运算中需要加载内存中的数据，需要通过 DS 找到内存中的数据，加载到通用寄存器中，应
该如何加载呢？对于一个段，有一个起始的地址，而段内的具体位置，我们称为**偏移量**（Offset）。

在 CS 和 DS 中都存放着一个段的起始地址。代码段的偏移量在 IP 寄存器中，数据段的偏移量会放在通用寄存器中。
这时候问题来了，CS 和 DS 都是 16 位的，也就是说，起始地址都是 16 位的，IP 寄存器和通用寄存器都是 16 位的，偏移量也是 16 位的，但是 8086 的地址总线地址是 20 位。怎么凑够这 20 位呢？方法就是“起始地址 *16+ 偏移量”，也就是把 CS 和 DS 中的值左移 4 位，变成 20 位的，加上 16 位的偏移量，这样就可以得到最终 20 位的数据地址。
从这个计算方式可以算出，无论真正的内存多么大，对于只有 20 位地址总线的 8086 来讲，能够区分出的地址也就 2^20=1M，超过这个空间就访问不到了。这又是为啥呢？如果你想访问 1M+X的地方，这个位置已经超过 20 位了，由于地址总线只有 20 位，在总线上超过 20 位的部分根本是发不出去的，所以发出去的还是 X，最后还是会访问 1M 内的 X 的位置。
那一个段最大能有多大呢？因为偏移量只能是 16 位的，所以一个段最大的大小是 2^16=64k。

**32位处理器**

通用寄存器有扩展，可以将 8 个 16 位的扩展到 8 个 32 位的，但是依然可以保留 16 位的和 8 位的使用方式。

改动比较大，有点不兼容的就是**段寄存器**（Segment Register）。

CS、SS、DS、ES 仍然是 16 位的，但是不再是段的起始地址。段的起始地址放在内存的某个地方。这个地方是一个表格，表格中的一项一项是**段描述符**（Segment Descriptor）。这里面才是真正的段的起始地址。而段寄存器里面保存的是在这个表格中的哪一项，称为**选择子**（Selector）。

因而到了 32 位的系统架构下，我们将前一种模式称为实模式（Real Partern），后一种模式称为
保护模式（Protected Partern）。

![cpu和内存的交互](.\img\cpu和内存的交互.png)



**汇编语言的一些命令**

**mov** ：MOV  target，source

将源操作数source的值复制到target中去，source值不变

 **call**：过程调用

写法：CALL label；

作用：若label与该指令在同一代码段，则为段内直接调用，IP进栈，IP=label的偏移地址，如果是不在同一代码段，则为段间间接调用，CS:IP进栈，CS:IP=label的分段地址

写法：CALL reg16/mem16；

 **jmp**：无条件转移指令

执行代码的跳转，分为两种，一：段内转移，即要跳过去的代码地址和当前地址在同一段，这时只要修改IP（专用寄存器--指令指针）即可；二：段间转移：即要跳过去的代码地址和当前代码地址不在同一段内，需要同时修改CS和IP的值。

**int**：中断指令

写法：INT n；（n为中断号，取值为0~255）

通常，程序内部的跳转，用JMP或CALL，并且JMP和CALL得参数是要跳转的过程的入口指令地址，而INT则是调用系统提供的中断服务程序，并且参数是中断号，然后由CPU根据中断号去计算中断服务程序的入口地址，MS DOS使用中断号21H作为系统调用，一般INT中断的步骤如下：

（1）由AH给出中断号

（2）根据相应功能的要求，设置入口参数

（3）INT 21H

（4）分析和使用出口参数

比如如下代码实现程序的退出并返回DOS：

Mov ah，4ch；-----给出中断号

Int 21h； -----开始中断

说明：除了直接以AL或AX返回出口参数外，INT 21H还是用AL或AX作为返回码，对于功能号0~2eh，由AL返回0（表示成功）或1（表示失败）；其余功能号则由CF返回0或者1，并由AX返回错误码。

**ret**：过程返回

写法：RET ;

近返回或远返回  RETN；近返回；RETF;远返回

**add**：加法

写法：ADD reg/memreg/mem/imm

作用：将后面的操作数加到前面的操作数中

注意：两个操作数必须类型匹配，并且不能同时是内存操作数

 **or**：AND\TEST\OR\XOR，两个操作数必须类型匹配，而且不能同时是内存操作数。

 **xor**：通常用来将寄存器清0

**shl**：逻辑左移

写法：SHL REG\mem，1\CL ;

作用：将dest的各个二进制位向左移动1（CL）位，并将DEST的最高位移出到CF，最低位移入0。

**shr**：逻辑右移

写法：SHR REG\mem，1\CL ;

作用：将dest的各个二进制位向左移动1（CL）位，并将DEST的最低位移出到CF，最高位移入0。

**push** ：写法：PUSH reg16（32）/seg/mem16（32）/imm

功能描述：将通用寄存器/段寄存器/内存数/立即数的值压入栈中，即：

SP=SP-2SS:[SP]=16位数值（当将32位数值压入栈中时，SP=SP-4，SS:[SP]=32为数值）

 **pop**：出栈

写法：POP reg16（32）/seg/mem16（32）【不能出栈到CS中】

功能描述：将堆栈口的16（32）位数据推出到通用寄存器/段寄存器/内存中，即：寄存器/段寄存器/内存= SS:[SP]   SP=SP+2（当将32位数值出栈时，SP=SP+4）（注意，不能出栈给立即数哦，常量不可变嘛）

 **inc**：自加一

写法：INC reg/mem；

作用：dest=dest+1；

 **dec**：自减1

写法：DEC reg/mem；

作用：dest=dest-1

**sub**：减法

写法：SUB reg/mem， reg/mem/imm；

作用：dest=dest-src；

 **cmp**：比较

写法：CMP reg/mem， reg/mem/imm

作用：dest-src

注意：这里并不将结果存入dest中，而仅仅是执行相减的运算，达到依据运算结果去影响EFLAG标志位的效果































