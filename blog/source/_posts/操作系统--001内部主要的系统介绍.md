---
title: 操作系统--001内部主要的系统介绍
date: 2019-09-19 
tags: [操作系统]
---



**进程管理**

创建进程的系统调用叫 `fork` 。

老的进程叫作父进程（Parent Process），新的进程叫作子进程（Child Process）。

Linux 就是这样想的。当父进程调用 fork 创建进程的时候，子进程将各个子系统为父进程创建的数据结构也全部拷贝了一份，甚至连程序代码也是拷贝过来的。

对于 fork 系统调用的返回值，如果当前进程是子进程，就返回 0；如果当前进程是父进程，就返回子进程的进程号。

操作系统启动的时候先创建一个所有用户进程的“祖宗进程”。

有个系统调用 `waitpid`，父进程可以调用它，将子进程的进程号作为参数传给它，这样父进程就知道子进程运行
完了没有，成功与否。

**内存管理**

每个进程都有自己的内存，互相之间不干扰，有独立的进程内存空间。

对于进程的内存空间来讲，放程序代码的这部分，我们称为代码段（Code Segment）。对于进程的内存空间来讲，放进程运行中产生数据的这部分，我们称为数据段（DataSegment）。其中局部变量的部分，在当前函数执行的时候起作用，当进入另一个函数时，这个变量就释放了；也有动态分配的，会较长时间保存，指明才销毁的，这部分称为堆（Heap）。

一个进程的内存空间是很大的，32 位的是 4G，64 位的就更大了。但是进程自己不用的部分就不用管，只有进程要去使用部分内存的时候，才会使用内存管理的系统调用来登记，说自己马上就要用了，希望分配一部分内存给它，但是这还不代表真的就对应到了物理内存。只有真的写入数据的时候，发现没有对应物理内存，才会触发一个中断，现分配物理内存。

个在堆里面分配内存的系统调用，`brk`和`mmap`。

当分配的内存数量比较小的时候，使用 `brk`，会和原来的堆的数据连在一起，这就像多分配两三个工位，在原来的区域旁边搬两把椅子就行了。当分配的内存数量比较大的时候，使用 `mmap`，会重新划分一块区域，也就是说，当办公空间需要太多的时候，索性来个一整块。



**文件管理**

创建、打开、读、写等操作。

对于已经有的文件，可以使用`open`打开这个文件，`close`关闭这个文件；
对于没有的文件，可以使用`creat`创建文件；
打开文件以后，可以使用`lseek`跳到文件的某个位置；
可以对文件的内容进行读写，读的系统调用是`read`，写是`write`。

Linux 里有一个特点，那就是一切皆文件。

每个文件，Linux 都会分配一个文件描述符（File Descriptor），这是一个整数。有了这个文件描述符，我们就可以使用系统调用，查看或者干预进程运行的方方面面。

**信号处理**

在执行一个程序的时候，在键盘输入“CTRL+C”，这就是中断的信号，正在执行的命令就会中止退出；

硬件故障;

如果非法访问内存;

用户进程通过kill函数，将一个用户信号发送给另一个进程。

每种信号都定义了默认的动作，例如硬件故障，默认终止；也可以提供信号处理函数，可以通过`sigaction`系统调用，注册一个信号处理函数。



**进程间通信**

首先就是发个消息，不需要一段很长的数据，这种方式称为消息队列（Message Queue）。由于一个公司内的多个项目组沟通时，这个消息队列是在内核里的，我们可以通过`msgget`创建一个新的队列，msgsnd将消息发送到消息队列，而消息接收方可以使用`msgrcv`从队列中取消息。

共享内存可以用于交互比较大的信息。

通过`shmget`创建一个共享内存块，通过`shmat`将共享内存映射到自己的内存空间，然后就可以读写了。

为了避免同时修改共享数据产生并发异常，就需要让不同的人能够排他地访问，这就是信号量的机制**Semaphore**。

简单实现：对于只允许一个人访问的需求，我们可以将信号量设为 1。当一个人要访问的时候，先调用`sem_wait`。如果这时候没有人访问，则占用这个信号量，他就可以开始访问了。如果这个时候另一个人要访问，也会调用 `sem_wait`。由于前一个人已经在访问了，所以后面这个人就必须等待上一个人访问完之后才能访问。当上一个人访问完毕后，会调用`sem_post`将信号量释放，于是下一个人等待结束，可以访问这个资源了。

**网络通信**

不同机器的通过网络相互通信，要遵循相同的网络协议，也即TCP/IP 网络协议栈。Linux 内核里有对于网络协议栈的实现。网络服务是通过套接字 Socket 来提供服务的。

我们可以通过 Socket 系统调用建立一个 Socket。Socket 也是一个文件，也有一个文件描述符，也可以通过读写函数进行通信。



**Glibc**

Glibc 是 Linux 下使用的开源的标准 C 库，它是 GNU 发布的 libc 库。Glibc 为程序员提供丰富的API，除了例如字符串处理、数学运算等用户态服务之外，最重要的是封装了操作系统提供的系统服务，即系统调用的封装。

1. Glibc 一个单独的 API 可能调用多个系统调用，比如说，Glibc 提供的 printf 函数就会调用如 sys_open、sys_mmap、sys_write、sys_close 等等系统调用。

2. 多个 API 也可能只对应同一个系统调用，如 Glibc 下实现的 malloc、calloc、free 等函数用来分配和释放内存，都利用了内核的 sys_brk 的系统调用。



![微信图片_20190919143129](.\img\微信图片_20190919143129.png)











